\subsection{Использование доказывателя теорем Z3 для доказательства эквивалентности одной странной альтернативы XOR}
\label{weird_XOR}

(Этот текст впервые был опубликован в моем блоге в апреле 2015: \url{http://blog.yurichev.com/node/86}).

Существует программа ``A Hacker's Assistant''\footnote{\url{http://www.hackersdelight.org/}}
(\textit{Aha!}) написанная Генри Уоренном, который также автор замечательной книги
``Hacker's Delight''.

Программа \textit{Aha!} работает как \textit{супероптимизатор}\footnote{\url{http://en.wikipedia.org/wiki/Superoptimization}},
который тупо пробует брутфорсом список некоторых распространенных инструкций RISC CPU, для поиска самой короткой
(и без переходов) последовательности инструкций для желаемой операции.
Например, \textit{Aha!} может легко найти версию ф-ции abs() без переходов.

Разработчики компиляторов используют супероптимизацию для поиска самого короткого (и/или без переходов) кода,
но я попробовал наоборот --- найти самый длинный код для какой-нибудь примитивной операции.
При помощи \textit{Aha!} я попробовал найти эквивалент обычной инструкции исключеющего ИЛИ без использования самой
операции исключающего ИЛИ, и самый странный пример что выдал \textit{Aha!}, это:

\begin{lstlisting}
Found a 4-operation program:
   add   r1,ry,rx
   and   r2,ry,rx
   mul   r3,r2,-2
   add   r4,r3,r1
   Expr: (((y & x)*-2) + (y + x))
\end{lstlisting}

Трудно сказать, зачем и где это можно использовать, может быть для обфускации, н езнаю.
Я бы назвал это \textit{субоптимизацией} (противопоставляя \textit{супероптимизации}).
Или, может быть, \textit{супердеоптимизацией}.

Но другой вопрос это, возможно ли доказать, что это вообще корректная формула?
\textit{Aha!} проверяет некоторые входные/выходные значения на операции исключающего ИЛИ, но конечно, не все
возможные значения.
Это 32-битный код, так что пробовать все возможные 32-битные входы для тестирования будет долго.

Можно попробовать доказыватель теорем Z3. Все-таки, он же называется \textit{доказыватель (prover)}.

Так что я написал это:

\begin{lstlisting}
#!/usr/bin/python
from z3 import *

x = BitVec('x', 32)
y = BitVec('y', 32)
output = BitVec('output', 32)
s = Solver()
s.add(x^y==output)
s.add(((y & x)*0xFFFFFFFE) + (y + x)!=output)
print s.check()
\end{lstlisting}

На обычном русском языке, это означает
``есть ли здесь какой-нибудь случай для $x$ и $y$, для которых $x \oplus y$ не будет равно $((y \& x)*-2) + (y + x)$?''
\dots и Z3 выводит ``unsat'', что означает, что он не смог найти ни одного контрпримера для этого уравнения.
Так что мы доказали, что этот результат \textit{Aha!} работает точно также, как и операция исключающего ИЛИ.

Я также попробовал расширить формулу до 64-х бит:

\begin{lstlisting}
#!/usr/bin/python
from z3 import *

x = BitVec('x', 64)
y = BitVec('y', 64)
output = BitVec('output', 64)
s = Solver()
s.add(x^y==output)
s.add(((y & x)*0xFFFFFFFE) + (y + x)!=output)
print s.check()
\end{lstlisting}

Нет, теперь он говорит ``sat'', означая, что Z3 смог найти минимум один контрпример.
Оопс, это потому что я забыл расширить число -2 до 64-битного значения:

\begin{lstlisting}
#!/usr/bin/python
from z3 import *

x = BitVec('x', 64)
y = BitVec('y', 64)
output = BitVec('output', 64)
s = Solver()
s.add(x^y==output)
s.add(((y & x)*0xFFFFFFFFFFFFFFFE) + (y + x)!=output)
print s.check()
\end{lstlisting}

Теперь он говорит ``unsat'', так что формула выданная \textit{Aha!} также хорошо работает и для 64-битного кода.

\subsubsection{В виде SMT-LIB}

Мы можем переписать наше уравнение в более удобном виде: $(x + y - ((x \& y)<<1))$.
Это также хорошо работает в Z3Py:

\begin{lstlisting}
#!/usr/bin/python
from z3 import *

x = BitVec('x', 64)
y = BitVec('y', 64)
output = BitVec('output', 64)
s = Solver()
s.add(x^y==output)
s.add((x + y - ((x & y)<<1)) != output)
print s.check()
\end{lstlisting}

Вот как я определяю это в виде SMT-LIB:

\begin{lstlisting}
(declare-const x (_ BitVec 64))
(declare-const y (_ BitVec 64))
(assert 
	(not
		(=
			(bvsub
				(bvadd x y)
				(bvshl (bvand x y) (_ bv1 64)))
			(bvxor x y)
		)
	)
)
(check-sat)
\end{lstlisting}

\subsubsection{Используя универсальный квантификатор}

Z3 поддерживает универсальный квантификатор \TT{exists}, который будет истинен,
если минимум один набор переменных удовлетворяет этому условию:

\begin{lstlisting}
(declare-const x (_ BitVec 64))
(declare-const y (_ BitVec 64))
(assert 
	(exists ((x (_ BitVec 64)) (y (_ BitVec 64)))
		(not (=
			(bvsub 
				(bvadd x y)
				(bvshl (bvand x y) (_ bv1 64))
			)
			(bvxor x y)
		))
	)
)
(check-sat)
\end{lstlisting}

Это выдает ``unsat'', означая, что Z3 не смог найти ни один контрпример к этому уравнению, т.е., он не существует.\\
\\
Это также обозначается как $\exists$ на языке математической логики.\\
\\
Z3 также поддерживает универсальный квантификатор \TT{forall}, который истинен, если выражение истинно
для всех возможных значения.
Так что я могу переписать наш SMT-LIB пример так:

\begin{lstlisting}
(declare-const x (_ BitVec 64))
(declare-const y (_ BitVec 64))
(assert 
	(forall ((x (_ BitVec 64)) (y (_ BitVec 64)))
		(=
			(bvsub 
				(bvadd x y)
				(bvshl (bvand x y) (_ bv1 64))
			)
			(bvxor x y)
		)
	)
)
(check-sat)
\end{lstlisting}

Это выдает ``sat'', означая, что уравнение корректно для всех возможных значений \TT{x} и \TT{y},
как если бы они все были проверены.

Математически говоря: $\forall n\!\in\!\mathbb{N}\; (x \oplus y = (x + y - ((x \& y)<<1)))$
\footnote{
$\forall$ означает \textit{уравнение должно быть истинно для всех возможных значений}, которые выбраны из натуральных
чисел ($\mathbb{N}$).}

\subsubsection{Как работает это выражение}

Прежде всего, двоичное сложение можно рассматривать как применение исключающего ИЛИ с переносами (\ref{adder}).
Вот пример: сложим 2 (10b) и 2 (10b).
Если применить исключающее ИЛИ, результат будет 0, но во время складывания двух вторых бит генерируется перенос.
Этот перенос затем продвигается далее и остается на месте 3-го бита: 100b.
4 (100b) это, следовательно, конечный результат сложения.

Если биты переноса не генерируются во время сложения, операция сложения это просто исключающее ИЛИ.
Например, сложим 1 (1b) и 2 (10b). $1 + 2$ равно 3, но $1 \oplus 2$ это тоже 3.

Если сложение это просто исключающее ИЛИ без генерирования переносов (и их последующего применения), нам нужно
как-то избавиться от эффекта переноса.
Первая часть выражения ($x + y$) это сложение, вторая ($(x \& y)<<1$) это просто вычисление каждого бита переноса,
которые использовались при сложении.
Если вычесть биты переноса из результата сложения, остается только эффект от исключающего ИЛИ.

Трудно сказать как Z3 это доказал:
может быть он просто сократил уравнение вплоть до одной операции исключающего ИЛИ используя 
простые правила сокращения из булевой алгебры?

\subsubsection{В SAT}

См.также: \ref{weird_XOR_SAT}.

