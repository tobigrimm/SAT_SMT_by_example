\subsection{Головоломка о восьми ферзях}
\label{EightQueens}

Восемь ферзей это популярная головоломка, и она часто используется для измерения скорости работы SAT-солверов.
Нужно расставить на шахматной доске 8 ферзей так, чтобы они не атаковали друг друга.
Например:

\begin{lstlisting}
| | | |*| | | | |
| | | | | | |*| |
| | | | |*| | | |
| |*| | | | | | |
| | | | | |*| | |
|*| | | | | | | |
| | |*| | | | | |
| | | | | | | |*|
\end{lstlisting}

Попробуем разобраться, как её решить.

\subsubsection{POPCNT1}
\label{POPCNTOne}

Одна важная ф-ция, которую мы будем (часто) использовать это \TT{POPCNT1}.
Это ф-ция, которая возвращает \textit{Истинно}, если один из входов истинен, остальные ложны.
Она вернет \textit{Ложно} в остальных случаях.

В моих других примерах, я использовал Wolfram Mathematica для генерирования CNF-клозов для этого, например: \ref{minesweeper_SAT}.
Какое выражение сгенерирует Mathematica для ф-ции \TT{POPCNT1} для 8-и входов?

\begin{lstlisting}
(!a||!b)&&(!a||!c)&&(!a||!d)&&(!a||!e)&&(!a||!f)&&(!a||!g)&&(!a||!h)&&(a||b||c||d||e||f||g||h)&&
(!b||!c)&&(!b||!d)&&(!b||!e)&&(!b||!f)&&(!b||!g)&&(!b||!h)&&(!c||!d)&&(!c||!e)&&(!c||!f)&&(!c||!g)&&
(!c||!h)&&(!d||!e)&&(!d||!f)&&(!d||!g)&&(!d||!h)&&(!e||!f)&&(!e||!g)&&(!e||!h)&&(!f||!g)&&(!f||!h)&&(!g||!h)
\end{lstlisting}

Мы можем ясно увидеть что выражение состоит из всех возможных пар переменных (инвертированных) плюс
перечисление всех переменных (не инвертированных).
На обычном русском языке это означает: ``ни одна пара не должна быть равна двум \textit{Истинно} \textit{И}
по крайней мере одно \textit{Истинно} должно
присутствовать среди переменных''.

Вот как это работает: если две переменных будут \textit{Истино}, инвертированными они обе будут \textit{Ложно},
и этот клоз не будет
вычислен как \textit{Истинно}, а это наша конечная цель.
Если одна из переменных будет \textit{Истинно}, инвертированными, одна будет \textit{Истинно},
вторая \textit{Ложно} (хорошо).
Если обе переменных будут \textit{Ложно}, инвертированными, они обе будут \textit{Истинно} (тоже хорошо).

Вот как мы можем сгенерировать клозы для этой ф-ции используя модуль \textit{itertools} из Питона,
который также содержит много важных ф-ций из комбинаторики:

\begin{lstlisting}
    # naive/pairwise encoding   
    def AtMost1(self, lst):
        for pair in itertools.combinations(lst, r=2):
            self.add_clause([self.neg(pair[0]), self.neg(pair[1])])
        
    def POPCNT1(self, lst):
        self.AtMost1(lst)
        self.OR_always(lst)
\end{lstlisting}

Ф-ция \TT{AtMost1()} перечисляет все возможные пары используя ф-цию \textit{combinations()} из
\textit{itertools}.

Ф-ция \TT{POPCNT1()} делает то же самое, только добавляет последний клоз, который заставляет иметь хотя бы одну
переменную, равную Истинно.

Какие клозы будут сгенерированы для 5-и переменных (1..5)?

\lstinputlisting{SAT/8queens/popcnt1.cnf}

Да, это все возможные пары чисел 1..5 + все 5 чисел.

Можем посмотреть все решения используя Picosat:

\begin{lstlisting}
% picosat --all popcnt1.cnf
s SATISFIABLE
v -1 -2 -3 -4 5 0
s SATISFIABLE
v -1 -2 -3 4 -5 0
s SATISFIABLE
v -1 -2 3 -4 -5 0
s SATISFIABLE
v -1 2 -3 -4 -5 0
s SATISFIABLE
v 1 -2 -3 -4 -5 0
s SOLUTIONS 5
\end{lstlisting}

Действительно, 5 возможных решений.

\subsubsection{Восемь ферзей}

Теперь вернемся назад к восьми ферзям.

Мы можем назначить 64 переменных для $8 \cdot 8=64$ клеток.
Клетка на которой есть ферзь будет равна \textit{Истинно}, пустая клетка будет \textit{Ложно}.

Проблема расположения неатакующих (друг друга) ферзей на шахматной доске (любого размера), на обычном русском
языке может быть выражена так:

\begin{itemize}
\item один единственный ферзь должен присутствовать в каждом ряду;

\item один единственный ферзь должен присутствовать в каждом столбце;

\item или один ферзь должен присутствовать на каждой диагонали, или вовсе отсутствовать (пустые диагонали могут быть
и в правильном решении).
\end{itemize}

Эти правила можно перевести так:

\begin{itemize}
\item POPCNT1(каждый ряд)==\textit{Истинно}

\item POPCNT1(каждый столбец)==\textit{Истинно}

\item AtMost1(каждая диагональ)==\textit{Истинно}
\end{itemize}

Теперь мы должны перечислить ряды, столбцы и диагонали, и собрать все клозы:

\lstinputlisting{SAT/8queens/8queens.py}
( \url{https://github.com/dennis714/SAT_SMT_article/blob/master/SAT/8queens/8queens.py} )

Возможно, ф-ция \TT{gen\_diagonal()} выглядит не очень эстетично:
она перечисляет также поддиагонали более длинных диагоналей, которые уже были раннее.
Чтобы не было повторяющихся клозов, глобальная переменная \textit{clauses} это не список, а множество,
которое может содержать в себе только уникальные данные.

Также, я использовал ф-цию \TT{AtMost1} для каждого столбца, это поможет генерировать чуть меньше клозов.
Каждый столбец будет содержать ферзя в любом случае, это следует из первого правила (\TT{POPCNT1} для каждого ряда).

После запуска, получаем CNF-файл с 64-я переменными и 736-я клозами (\url{https://github.com/dennis714/SAT_SMT_article/blob/master/SAT/8queens/8queens.cnf}).
Вот одно из решений:

\begin{lstlisting}
% python 8queens.py
len(clauses)= 736
| | | |*| | | | |
| | | | | | |*| |
| | | | |*| | | |
| |*| | | | | | |
| | | | | |*| | |
|*| | | | | | | |
| | |*| | | | | |
| | | | | | | |*|
\end{lstlisting}

Как много здесь возможных решений?
Picosat говорит что 92, что действительно корректное число решений (\url{https://oeis.org/A000170}).

Скорость Picosat не очень впечатляет, вероятно потому что ему приходится выводить все решения.
Моему древнему нетбуку с Intel Atom 1.66GHz, понадобилось 34 для перечисления всех решений для шахматной доски
$11 \cdot 11$ 
(2680 решения),
что намного медленнее, чем моя прямолинейная программа полного перебора: \url{https://yurichev.com/blog/8queens/}.
Тем не менее, для поиска первого решения, Picosat работает крайне быстро (как и другие SAT-солверы).

Эта SAT-задача также достаточно проста, чтобы её можно было легко решить при помощи моего простейшего
SAT-солвера, работающего на базе поиска с возвратом (\textit{backtracking}):
\ref{SAT_backtrack}.

\subsubsection{Подсчет всех решений}

Мы получаем решение, инвертируем его и добавляем как новый констрайнт.
На обычном русском языке это звучит ``найди решение, котороые также не ровно тому, что мы только что нашли/добавили''.
Мы добавляем их последовательно, и процесс замедляется --- потому что размер проблемы (\textit{instance}) растет 
и SAT-солверу всё труднее находить новое решение.

\subsubsection{Пропуск симметрических решений}

Мы также можем добавлять повернутое и отраженное (горизонтально) решение, чтобы пропускать симметрические решения.
Делая так, мы получаем 12 решений для доски 8*8, 46 для 9*9, итд.
Это \url{https://oeis.org/A002562}.

